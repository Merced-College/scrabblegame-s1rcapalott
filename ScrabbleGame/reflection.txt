Working on this Scrabble-style game deepened my understanding of object-oriented programming in a practical way. At the start, I understood the basic ideas of classes and constructors, but applying them to a real project helped me think more critically about structure and responsibility. For example, separating the Word class and the ScrabbleGame class showed me how to design objects that model data (Word) versus logic and interaction (ScrabbleGame). This helped me see how clean design can make programs easier to manage and extend.
Using an ArrayList to store the dictionary words also taught me about working with dynamic data structures. I had to sort the list to prepare for binary search, which helped me understand why sorting is important for certain algorithms to work efficiently. I also learned how to load large amounts of data from a file and turn each entry into an object.
One of the biggest challenges was ensuring that the game only gave the user letter sets that could actually form real words. The original version randomly generated letters, but many combinations were unsolvable. To fix this, I added an improvement where the game randomly selects a real word from the dictionary, shuffles its letters, and gives the user four of them. This guaranteed solvable puzzles and significantly improved the user experience.
Another issue was a crash caused when the word list file wasn’t found. The method generatePlayableLetters() relies on that list, so without it, the program failed with a bound must be positive error. I didn’t understand the cause at first, but by reading the error message and checking the code line it pointed to, I realized the file wasn’t loading. That’s when I debugged the issue and found a huge dictionary of words online to implement into the game.
Throughout the project, I used OpenAI’s ChatGPT to help me troubleshoot, plan improvements, and explain why certain things were happening as I coded. I asked questions like what should my word class should consist of, how to structure a loop to allow replay, and what my binary search method should look like. I tested the code step by step, recompiling after each major change to make sure nothing broke. 

